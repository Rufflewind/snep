#!/usr/bin/env python
from __future__ import print_function, unicode_literals
import os, re, subprocess, sys
from util import *

try:
    import urllib.parse as urllib_parse
except ImportError:
    import urlparse

class Config(object):

    def __init__(self, extensions=(), shebangs=(), syntaxes=()):
        # Dict SyntaxNameStr (FrozenSet ExtensionStr)
        self.extensions = dict(extensions)
        # Dict SyntaxNameStr (Tuple RegexStr)
        self.shebangs = dict(shebangs)
        # Dict SyntaxNameStr (RegexStr, RegexStr)
        self.syntaxes = dict(syntaxes)

    def __repr__(self):
        return ("Config({0}, {1}, {2})"
                .format(repr(self.extensions),
                        repr(self.shebangs),
                        repr(self.syntaxes)))

def detect_syntax_names(config, path, indexedLines):

    # guess based on the file extension
    _, ext = os.path.splitext(path)
    ext = ext[1:]
    syntax_names = []
    for syntax_name, extensions in config.extensions.items():
        if ext in extensions:
            syntax_names.append(syntax_name)
    if syntax_names:
        return tuple(syntax_names)

    # find the shebang
    try:
        index, line0 = next(indexedLines)
    except StopIteration:
        return ()
    if not (index == 0 and line0.startswith("#!")):
        return ()

    # guess based on the shebang
    syntax_names = set()
    for syntax_name, shebang_regexes in config.shebangs:
        for shebang_regex in shebang_regexes:
            if re.search(shebang_regex, line0):
                syntax_names.add(syntax_name)
    if len(syntax_names) != 1:
        return ()
    return (syntax_names.pop(),)

'''
def parse_path(uri):
    result = urllib_parse.urlsplit(uri, scheme="file", allow_fragments=False)
    scheme = result.scheme
    netloc = result.netloc
    path = result.path
    if result.query or uri.endswith("?"):
        path += "?" + result.query

    # https://foobar/foo#snip=snip1
    # git+https://alpha/foo#rev=HEAD&path=myfile.txt&snip=snip1

    if scheme == "file":

    urlparse.urlunsplit(parts)

    protocols = [
        "file",
        "ssh",
        "git(+\w+)?",
    ]
    m = re.match(r"([+\w]+):(.*)", path)
    if not m:
        protocol = "file"
    else:
        scheme, path = m.groups()

    m = re.match(r"//(.*)", path)
    if m:
        path, = m.groups()


    "://github.com/foo/bar.git:b/master:dir/file:snippet1"
'''

def parse_directives(indexed_lines, syntaxes):
    for i, line in indexed_lines:
        for syntax in syntaxes:
            pattern = "\s*" + syntax[0] + "(.*)" + syntax[1] + "\s*$"
            m = re.match(pattern, line)
            if m:
                yield i, "directive", m.group(1).strip()
                break
        else:
            yield i, "line", line

class Snippet(object):

    def __init__(self, name="", children=[], attributes={}):
        self.name = ""
        self.children = list(children)
        self.attributes = dict(attributes)

    def __repr__(self):
        return ("Snippet({0}, {1}, {2})"
                .format(repr(self.name),
                        repr(self.children),
                        repr(self.attributes)))

    def repack(self):
        '''[mutating] Concatenate adjacent strings recursively.'''
        str_chain = []
        children = []
        for child in self.children:
            if isinstance(child, Snippet):
                s = "".join(str_chain)
                if s:
                    children.append(s)
                child.repack()
                children.append(child)
            else:
                str_chain.append(child)
        s = "".join(str_chain)
        if s:
            children.append(s)
        self.children = children

def parse_snippet(indexed_directive_lines, name=""):
    snippet = Snippet(name)
    for i, line_type, line in indexed_directive_lines:
        if line_type == "line":
            snippet.children.append(line)
        elif line_type == "directive":
            m = re.match("(\S+)\s*(.*)", line)
            if not m:
                continue
            cmd, args = m.groups()
            if cmd == "begin":
                s = parse_snippet(indexed_directive_lines, args.strip())
                snippet.children.append(s)
            elif cmd == "end":
                end_name = args.strip()
                if end_name and end_name != snippet.name:
                    raise Exception("non-matching name in 'end' (line {0})"
                                    .format(i))
                return snippet
            elif cmd == "set":
                key, value = args.split("=", 1)
                snippet.attributes[key.strip()] = value.strip()
        else:
            assert False
    return snippet

def ls(config, args):
    path = args.PATH
    with open(path, "rt") as f:
        indexed_lines = enumerate(read_every_line(f))
        syntaxes = detect_syntax_names(config, path, indexed_lines)
        indexed_directive_lines = parse_directives(indexed_lines, syntaxes)
        snippet = parse_snippet(indexed_directive_lines)
        snippet.repack()
        for child in snippet.children:
            print("1", child)

def rm(config, args):
    path = args.PATH
    print("rm", path)

def nonempty_lines(s):
    for x in s.split("\n"):
        x = x.strip()
        if x:
            yield x

def config_from_file(filename):
    import configparser
    p = configparser.RawConfigParser()
    p.read(filename)
    c = Config()
    for syntaxName, extensions in p["extensions"].items():
        c.extensions[syntaxName] = tuple(extensions.split())
    for syntaxName, shebangRegexes in p["shebangs"].items():
        c.shebangs[syntaxName] = tuple(nonempty_lines(shebangRegexes))
    for syntaxName, syntaxRegexes in p["syntaxes"].items():
        syntaxRegexes = tuple(nonempty_lines(syntaxRegexes))
        if len(syntaxRegexes) != 2:
            raise Exception("Expected only 2 regexes for: {0}"
                            .format(syntaxName))
        c.syntaxes[syntaxName] = syntaxRegexes
    return c

def load_config():
    return config_from_file("snep.conf")

def parse_args():
    import argparse
    p = argparse.ArgumentParser(
        description="A basic snipulator.",
    )
    p.add_argument("-s", "--syntax",
                   metavar="SYNTAXES",
                   help="override the syntax")
    sp = p.add_subparsers(help="subcommand")

    spp = sp.add_parser("ls", help="list snippets")
    spp.add_argument("PATH", help="path to file and/or snippet")
    spp.set_defaults(func=ls)

    spp = sp.add_parser("rm", help="remove snippet(s)")
    spp.add_argument("PATH", help="path to file and/or snippet")
    spp.set_defaults(func=rm)

    return p.parse_args()

def main():
    args = parse_args()
    func = getattr(args, "func")
    if not func:
        p.print_usage()
        exit(1)
    func(load_config(), args)

if __name__ == "__main__":
    main()
