#!/usr/bin/env python
from __future__ import print_function, unicode_literals
import functools, os, re, sys
sys.path.insert(0, os.path.realpath(
    os.path.join(os.path.dirname(__file__), "../lib")))
import snep
import snep.merge
import snep.utils as utils

class BuiltinSnippet(object):

    def __init__(self, type, name):
        self.type = type
        self.name = name
        self.requires = frozenset()

class Snippet(object):

    def __init__(self, element):
        self.type = None
        self.name = element.name
        self.requires = frozenset(
            element.attributes.get("requires", "").split())
        self.element = element

    def __repr__(self):
        return "Snippet({0!r})".format(self.element)

def find_nonunique_element_name(element):
    if not element.has_unique_elements:
        for name in element.elements:
            if name not in element.unique_elements:
                return name
        assert False

def find_all_snippets(element):
    snips = element.get_element("snips")
    nonunique_element_name = find_nonunique_element_name(snips)
    if nonunique_element_name is not None:
        raise ValueError("non-unique element: {0}"
                         .format(nonunique_element_name))
    return map(Snippet, snips.unique_elements.values())

def get_builtin_snippet(name):
    args = name.split(":", 1)
    if len(args) == 2:
        return BuiltinSnippet(*args)

def get_snippet(snippets, name):
    snip = get_builtin_snippet(name)
    if snip is not None:
        return snip
    return snippets[name]

class SnippetCache(object):

    def __init__(self, doc_cache, search_path):
        self.search_path_stack = list(reversed(search_path))
        self.doc_cache = doc_cache
        self.snip_cache = {}

    def get_snippet(self, name):
        while True:
            snip = self.snip_cache.get(name, None)
            if snip is not None:
                return snip
            snip = get_builtin_snippet(name)
            if snip is not None:
                return snip
            if not self.search_path_stack:
                break
            self._load_document(self.search_path_stack.pop())
        raise ValueError("can't find snippet: {0}".format(name))

    def _load_document(self, fn):
        doc = self.doc_cache[fn]
        for snip in find_all_snippets(doc):
            if snip.name not in self.snip_cache:
                self.snip_cache[snip.name] = snip

def get_deps(snippets, requires):
    def neighbors_func(dep):
        return snippets(dep).requires
    return utils.reachable_set(requires, neighbors_func)

def get_and_split_deps(snippets, requires):
    deps = get_deps(snippets, requires)
    mods = []
    mod_deps = []
    for dep in deps:
        snip = get_builtin_snippet(dep)
        if snip and snip.type == "mod":
            mod_deps.append(dep)
            mods.append(snip.name)
    mods.sort()
    deps.difference_update(mod_deps)
    return deps, mods

def install_required_snips(doc, snippets, purge):
    requires_all = doc.get_element("snips").unique_elements
    # requires_only is what is needed if --purge was specified
    requires_only = Snippet(doc).requires or requires_all
    requires = set(requires_only)
    if not purge:
        requires.update(requires_all)
    # TODO: gracefully handle missing dependencies
    deps, mods = get_and_split_deps(snippets, requires)
    doc = doc.replace_element_children(
        "imports", [snep.Text("import {0}\n".format(mod)) for mod in mods])
    graph = dict((dep, [x for x in snippets(dep).requires
                        if not get_builtin_snippet(x)]) for dep in deps)
    snip_names = utils.toposort(graph)
    snips = []
    for name in snip_names:
        if snips:
            snips.append(snep.Text("\n"))
        snips.append(snippets(name).element)
    # TODO: warn before deleting any existing snippets
    #       (deletions should only happen with --purge)
    return doc.replace_element_children("snips", snips)

def ls(in_fn):
    doc = snep.parse_doc_file(in_fn)
    sys.stdout.write(utils.json_pretty(doc.to_json()))

def check_for_garbage(snips):
    for child in snips.children:
        if isinstance(child, snep.Element):
            continue
        garbage = child.render().strip()
        if not garbage:
            continue
        raise ValueError("{0}: found garbage in interstitial spaces: {1}"
                         .format(child.origin.filename, garbage))

def sync(fn1, fn2, purge):
    doc_cache = utils.FileCache(snep.parse_doc_file)

    doc1 = doc_cache[fn1]
    snips1 = doc1.get_element("snips")
    doc2 = doc_cache[fn2]
    snips2 = doc2.get_element("snips")

    check_for_garbage(snips1)
    check_for_garbage(snips2)

    # TODO: do some basic validation
    # - make sure there's no nonwhitespace in the interstitial spaces
    # - make sure the 'imports' element contains only import-like entries

    # sanity checks on the document format

    nonunique_element_name = find_nonunique_element_name(snips1)
    if nonunique_element_name is not None:
        raise ValueError("{0}: non-unique snippet: {1}"
                         .format(fn1, nonunique_element_name))
    nonunique_element_name = find_nonunique_element_name(snips2)
    if nonunique_element_name is not None:
        raise ValueError("{0}: non-unique snippet: {1}"
                         .format(fn2, nonunique_element_name))

    # step I: merge snippets

    common_snips = set(snips1.unique_elements)
    common_snips.intersection_update(snips2.unique_elements)
    conflicting_snips1 = {}
    conflicting_snips2 = {}
    for name in common_snips:
        snip1 = snips1.get_element(name)
        snip2 = snips2.get_element(name)
        if snip1 != snip2:
            conflicting_snips1[name] = snip1.replace_name(None).render()
            conflicting_snips2[name] = snip2.replace_name(None).render()
    if conflicting_snips1:
        merge_result = snep.merge.interactive_merge(conflicting_snips1,
                                                    conflicting_snips2)
        if merge_result is None:
            sys.stderr.write("Canceled.\n")
            sys.stderr.flush()
            exit(1)
        if frozenset(merge_result) != frozenset(conflicting_snips2):
            sys.stderr.write("Error: snippets were added or removed "
                             "during merge.\n")
            sys.stderr.flush()
            exit(1)
        for name, merge_snip_str in merge_result.items():
            snip = snep.parse_doc(merge_snip_str, name)
            snips1 = snips1.replace_element_children(name, snip.children)
            snips2 = snips2.replace_element_children(name, snip.children)
        doc1 = doc1.replace_element_children("snips", snips1.children)
        doc2 = doc2.replace_element_children("snips", snips2.children)

    # step II: resolve dependencies

    snips = dict(snips1.unique_elements)
    snips.update(snips2.unique_elements)
    for name in snips:
        snips[name] = Snippet(snips[name])
    get_snip = functools.partial(get_snippet, snips)

    doc1 = install_required_snips(doc1, get_snip, purge)
    doc2 = install_required_snips(doc2, get_snip, purge)

    os.rename(fn1, fn1 + ".orig")
    with open(fn1, "wb") as f:
        f.write(doc1.render().encode("utf-8"))

    os.rename(fn2, fn2 + ".orig")
    with open(fn2, "wb") as f:
        f.write(doc2.render().encode("utf-8"))

    # if a dependency is not there, then we produce a warning
    # "not all dependencies are resolved; missing the following snippets:\n{0}"
    #
    # in the future, when we handle multiple files together,
    # we will silence the warning unless the dependency cannot be found in -any-
    # of the given fiels

def argparser():
    import argparse
    p = argparse.ArgumentParser()
    sp = p.add_subparsers(help="subcommand")

    spp = sp.add_parser("ls")
    spp.add_argument("in_fn", metavar="filename")
    spp.set_defaults(func=ls)

    spp = sp.add_parser("sync")
    spp.add_argument("fn1", metavar="file1")
    spp.add_argument("fn2", metavar="file2")
    spp.add_argument("--purge", action="store_true")
    spp.set_defaults(func=sync)

    return p

def main():
    parser = argparser()
    args = vars(parser.parse_args())
    func = args.pop("func", None)
    if not func:
        parser.print_usage(sys.stderr)
        exit(1)
    try:
        func(**args)
    except snep.ParseError as e:
        sys.stderr.write("{0}:{1}: {2}\n".format(e.src, e.row, e.msg))
        sys.stderr.flush()
        exit(1)
    except KeyboardInterrupt:
        exit(1)

if __name__ == "__main__":
    main()
